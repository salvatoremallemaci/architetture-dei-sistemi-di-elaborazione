; DATA SECTION

.data
  # dichiaro l'array per multipli di 64 bit, al fine di occupare la memoria in modo consequenziale,
  #	dunque 4 parole da 16 bit per riga
  
  a:	.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		.word16 0x2f, 0x2f, 0x2f, 0x2f
		
  res:  .space 1
  val:	.byte 0x2f
  
; CODE SECTION
.text
MAIN:
 
		daddui 	R1, R0, 200  		# contatore ciclo da decrementare (R1 uguale a 0 = fine ciclo); array da 10 --> 20 cicli, ogni valore splittato in 2
		dadd  	R2, R0, R0  		# offset ciclo
		dadd  	R3, R0, R0  		# registro cumulatore da salvare in res
		lbu 	R8, val(R0)

FOR:    
		lbu   	R4, a(R2)  			# carico in R4 un byte dell'i-esimo valore dell' array
		and 	R5, R4, R8			# carico val in R5, per confronti
		bne		R5, R8, SKIP
		
		daddi 	R3, R3, 1			# incremento contatore occorrenze	

SKIP:	
		daddi	R2, R2, 1			# incremento puntatore di un 1 byte
		
		bne 	R1, R2, FOR
		
		sd 		R3, res(R0)
		
		halt
